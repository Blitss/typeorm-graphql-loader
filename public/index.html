<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@mando75/typeorm-graphql-loader</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@mando75/typeorm-graphql-loader</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>@mando75/typeorm-graphql-loader</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#typeorm-graphql-relation-loader" id="typeorm-graphql-relation-loader" style="color: inherit; text-decoration: none;">
					<h1>TypeORM GraphQL Relation Loader</h1>
				</a>
				<p>A dataloader for TypeORM that makes it easy to load TypeORM relations for
				GraphQL query resolvers.</p>
				<p><a href="https://badge.fury.io/js/%40mando75%2Ftypeorm-graphql-loader"><img src="https://badge.fury.io/js/%40mando75%2Ftypeorm-graphql-loader.svg" alt="npm version"></a>
					<img src="https://img.shields.io/npm/dm/@mando75/typeorm-graphql-loader" alt="npm">
					<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT"></a>
				<a href="https://gitlab.com/Mando75/typeorm-graphql-loader/commits/master"><img src="https://gitlab.com/Mando75/typeorm-graphql-loader/badges/master/pipeline.svg" alt="pipeline status"></a></p>
				<a href="#contents" id="contents" style="color: inherit; text-decoration: none;">
					<h2>Contents</h2>
				</a>
				<ul>
					<li><a href="#Description">Description</a></li>
					<li><a href="#Installation">Installation</a></li>
					<li><a href="#Usage">Usage</a></li>
					<li><a href="#Gotchas">Gotchas</a></li>
					<li><a href="#Roadmap">Roadmap</a></li>
					<li><a href="#API">API</a></li>
					<li><a href="#Contributing">Contributing</a></li>
					<li><a href="#Problem">Problem</a></li>
					<li><a href="#Solution">Solution</a></li>
					<li><a href="#Acknowledgments">Acknowledgments</a></li>
				</ul>
				<a href="#description-a-namedescription" id="description-a-namedescription" style="color: inherit; text-decoration: none;">
					<h2>Description <a name="Description"></h2>
				</a>
				<p>This package provides a <code>GraphQLDatabaseLoader</code> class, which is a caching
					loader that will trace through a GraphQL query info object and naively load the
					TypeORM fields and relations needed to resolve the query. For a more in-depth
				explanation, see the <a href="#Problem">Problem</a> and <a href="#Solution">Solution</a> sections below.</p>
				<a href="#installation-a-nameinstallation" id="installation-a-nameinstallation" style="color: inherit; text-decoration: none;">
					<h2>Installation <a name="Installation"></h2>
				</a>
				<pre><code class="language-bash">yarn add @mando75/typeorm-graphql-loader

<span class="hljs-comment"># OR</span>

npm install @mando75/typeorm-graphql-loader</code></pre>
				<p>This package requires that you have TypeORM installed as a peer dependency</p>
				<a href="#usage-a-nameusage" id="usage-a-nameusage" style="color: inherit; text-decoration: none;">
					<h2>Usage <a name="Usage"></h2>
				</a>
				<p>You should create a new GraphQLDatabaseLoader instance in each user session,
					generally via the GraphQLContext object. This is to help with caching and
					prevent user data from leaking between requests. The constructor takes a TypeORM
					connection as the first argument, and a GraphQLDatabaseLoaderOptions type as an
				optional second parameter.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> { GraphQLDatabaseLoader } <span class="hljs-keyword">from</span> <span class="hljs-string">'@mando75/typeorm-graphql-loader'</span>;
<span class="hljs-keyword">const</span> connection = createConnection({...}); <span class="hljs-comment">// Create your TypeORM connection</span>

<span class="hljs-keyword">const</span> apolloServer = <span class="hljs-keyword">new</span> ApolloServer({
  schema,
  context: {
    loader: <span class="hljs-keyword">new</span> GraphQLDatabaseLoader(connection, {<span class="hljs-comment">/** additional options if needed**})
  },
});</span></code></pre>
				<p>The loader will now appear in your resolver&#39;s context object:</p>
				<pre><code class="language-ts">Query: {
    getBookById(object: <span class="hljs-built_in">any</span>, args: {id: <span class="hljs-built_in">string</span> }, context: MyGraphQLContext, info: GraphQLResolveInfo) {
        <span class="hljs-keyword">return</span> context.loader
            .loadEntity(Book)
            .where({id})
            .info(info)
            .loadOne();
    }
}</code></pre>
				<p>Please note that the loader will only return back the fields and relations that
					the client requested in the query. If you need to ensure that certain fields are
				always returned, you can specify this using the <code>selectFields</code> method on the query builder.</p>
				<a href="#gotchas-a-namegotchas" id="gotchas-a-namegotchas" style="color: inherit; text-decoration: none;">
					<h2>Gotchas <a name="Gotchas"></h2>
				</a>
				<p>Because this package reads which relations and fields to load from the GraphQL query info object, the loader only works if your schema field names match your TypeORM entity field names. If it cannot find a requested GraphQL query field, it will not return it. In this case, you will need to provide a custom resolver for that field in your GraphQL resolvers file. In this case, the loader will provide the resolver function with an <code>object</code> parameter which is an entity loaded with whichever other fields your query requested. The loader will always return an object with at least the id (primary key) field loaded, so basic method calls should be possible. You can specify what your id field is called in the LoaderOptions upon loader initialization. That does require a uniform primary key naming strategy for your entire database schema. Be aware that you may need to reload the entity or provide some fields to the <code>selectFields</code> method for entity methods to work properly as not every entity database field is guaranteed to be loaded.</p>
				<p>This is not a complete replacement for Facebook&#39;s dataloader. package. While it does provide some batching, it&#39;s primary purpose is to load the relations and fields needed to resolve the query. In most cases, you will most likely not need to use dataloader when using this package. However, I have noticed in my own use that there are occasions where this may need to be combined with dataloader to remove N + 1 queries. One such case was a custom resolver for a many-to-many relation that existed in the GraphQL Schema but not on a database level. In order to completely remove the N+1 queries from that resolver, I had to wrap the TypeORM GraphQL loader in a Facebook DataLoader. If you find that you are in a situation where the TypeORM GraphQL loader is not solving the N+1 problem, please open an issue and I&#39;ll do my best to help you out with it. </p>
				<p>This package has currently only been tested with Postgresql and SQLite. In theory, everything should work with the other SQL variants that TypeORM supports, as it uses the TypeORM Query Builder API to construct the database queries. If you run into any issues with other SQL dialects, please open an issue.</p>
				<p>For help with pagination, first read <a href="https://gitlab.com/Mando75/typeorm-graphql-loader/-/blob/master/md/pagination.md">Pagination Advice</a></p>
				<a href="#api-a-nameapi" id="api-a-nameapi" style="color: inherit; text-decoration: none;">
					<h2>API <a name="API"></h2>
				</a>
				<p>Documentation for the Public API</p>
				<a href="#contributing-a-namecontributing" id="contributing-a-namecontributing" style="color: inherit; text-decoration: none;">
					<h2>Contributing <a name="Contributing"></h2>
				</a>
				<p>All development for this project is done on GitLab.com. However, I realize that many developers use GitHub as their primary development platform. If you do not use and do not wish to create a GitLab account, you can open an issue in the mirrored <a href="https://github.com/Mando75/typeorm-graphql-loader">GitHub Repository</a>. Please note that all merge requests must be done via GitLab as the GitHub repo is a read-only mirror. </p>
				<p>When opening an issue, please include the following information:</p>
				<ul>
					<li>Package Version</li>
					<li>Database and version being used</li>
					<li>TypeORM version</li>
					<li>GraphQL library being used</li>
					<li>Description of the problem</li>
					<li>Example code</li>
				</ul>
				<p>Please open an issue before opening any Merge Requests.</p>
				<a href="#problem-a-nameproblem" id="problem-a-nameproblem" style="color: inherit; text-decoration: none;">
					<h2>Problem <a name="Problem"></h2>
				</a>
				<p>TypeORM is a pretty powerful tool, and it gives you quite a bit of flexibility
					in how you manage entity relations. TypeORM provides 3 ways to load your
					relations, eagerly, manually, or lazily. For more info on how this works, see
				the <a href="https://typeorm.io/#/eager-and-lazy-relations">TypeORM Documentation</a>.</p>
				<p>While this API is great for having fine-grained control of you data layer, it
					can get frustrating to use in a GraphQL schema. For example, lets say we have
					three entities, User, Author, and Book. Each Book has an Author, and each Author
					has a User. We want to expose these relations via a GraphQL API. Our issue now
					becomes how to resolve these relations. Let&#39;s look at how an example resolver
				function might try to resolve this query:</p>
				<p>Query</p>
				<pre><code class="language-graphql">query bookById($id: ID!) {
  book(id: $id) {
    id
    name
    author {
      id
      user {
        id
        name
      }
    }
  }
}</code></pre>
				<p>We could do something simple like this:</p>
				<pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finBookById</span>(<span class="hljs-params">object, args, context, info</span>) </span>{
  <span class="hljs-keyword">return</span> Book.findOne(args.id);
}</code></pre>
				<p>but then the author and user relations won&#39;t be loaded. We can remedy that by
				specifying them in our find options like so:</p>
				<pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finBookById</span>(<span class="hljs-params">object, args, context, info</span>) </span>{
  <span class="hljs-keyword">return</span> Book.findOne(args.id, { relations: [<span class="hljs-string">"author"</span>, <span class="hljs-string">"author.user"</span>] });
}</code></pre>
				<p>however, this could get really nasty if we have many relations we may need.
					Well, we could just set all of our relations to eagerly load so we don&#39;t need to
					specify them, but then we may start loading a bunch of data we may never use
				which isn&#39;t very performant at scale.</p>
				<p>How about just defining a resolver for every relation and loading them as
					needed? That could work, but it seems like a lot of work and duplication of
				effort when we&#39;ve already specified our relations on the entity level.</p>
				<p>Another possible, and probably intuitive solution is to use lazy relations.
					Because lazy relations return Promises, as long as we give the resolver an
					instance of our Book entity, it will call each relation and wait for the Promise
				to resolve, fixing our problem. It let&#39;s us use our original resolver function</p>
				<pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finBookById</span>(<span class="hljs-params">object, args, context, info</span>) </span>{
  <span class="hljs-keyword">return</span> Book.findOne(args.id);
}</code></pre>
				<p>and ApolloServer will just automagically resolve the relation promises for us
					and return the data. Seems great right? It&#39;s not. This introduces a massive N+1
					problem. Now every time you query a subrelation, ApolloServer will inadvertently
					perform another database query to load the lazy relation. At small scale this
					isn&#39;t a problem, but the more complex your schema becomes, the harder it will
				hit your performance.</p>
				<a href="#solution-a-namesolution" id="solution-a-namesolution" style="color: inherit; text-decoration: none;">
					<h2>Solution <a name="Solution"></h2>
				</a>
				<p>This package offers a solution to take away all the worry of how you manage
					your entity relations in the resolvers. GraphQL provides a parameter in each
					resolver function called <code>info</code>. This <code>info</code> parameter contains the entire query
					tree, which means we can traverse it and figure out exactly which fields need to
					be selected, and which relations need to be loaded. This can then be used to
				create one SQL query that can get all of the information at once.</p>
				<p>Because the loader uses the queryBuilder API, it does not matter if you have all
					&quot;normal&quot;, &quot;lazy&quot;, &quot;eager&quot; relations, or a mix of all of them. You give it your
					starting entity and the GraphQL query info, and it will figure out what data you
					need and give it back to you in a structured TypeORM entity. Additionally, it
					provides some caching functionality as well, which will dedupe identical query
				signatures executed in the same tick.</p>
				<a href="#acknowledgments-a-nameacknowledgments" id="acknowledgments-a-nameacknowledgments" style="color: inherit; text-decoration: none;">
					<h2>Acknowledgments <a name="Acknowledgments"></h2>
				</a>
				<p>This project is based on the work of <a href="https://github.com/Webtomizer/typeorm-loader">Weboptimizer&#39;s typeorm-loader
					package</a>. I work quite a bit with
					Apollo Server + TypeORM and I was looking to find a way to more efficiently pull
					data via TypeORM for GraphQL via intelligently loading the needed relations for
					a given query. I stumbled across his package, which seemed to
					promise all the functionality, but it seemed to be in a broken/unmaintained
					state. After several months of no response from the author, and with significant
					bug fixes/features added in my fork, I decided to just make my own package. So
					thanks to Weboptimizer for doing a lot of the ground work. If you ever stumble
					across this and would like to merge the features back into the main source repo,
				I&#39;d be more than happy to work with you to make that happen.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-enum">
						<a href="enums/loadernamingstrategyenum.html" class="tsd-kind-icon">Loader<wbr>Naming<wbr>Strategy<wbr>Enum</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/loadersearchmethod.html" class="tsd-kind-icon">Loader<wbr>Search<wbr>Method</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/graphqldatabaseloader.html" class="tsd-kind-icon">GraphQLDatabase<wbr>Loader</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/graphqlquerybuilder.html" class="tsd-kind-icon">GraphQLQuery<wbr>Builder</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/loaderoptions.html" class="tsd-kind-icon">Loader<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/loaderwhereexpression.html" class="tsd-kind-icon">Loader<wbr>Where<wbr>Expression</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/querypagination.html" class="tsd-kind-icon">Query<wbr>Pagination</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/searchoptions.html" class="tsd-kind-icon">Search<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#whereargument" class="tsd-kind-icon">Where<wbr>Argument</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#whereexpression" class="tsd-kind-icon">Where<wbr>Expression</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>